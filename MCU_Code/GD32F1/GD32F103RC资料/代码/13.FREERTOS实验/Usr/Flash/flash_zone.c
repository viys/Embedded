/*************************************************************************************************************
File Name:
Descripton:
*************************************************************************************************************/
//------------------------------- include files ----------------------------------------
#include "flash_zone.h"
#include "fmc_erase.h"
//-------------------------------- macro define ----------------------------------------
// 创建链表来保存ID数据，将有效数据链接起来。将数据删除时要将链表重新调整连接。
// 注意：键表尾要指向链表头。
const myBkList_t Bk_DataZone1[] __attribute__((at(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))) = 
{//                           前一节点序号                                               后一节点序号                              空单元标志             分机编号               分机ID
	// 第一页
	{	( 0+NODES_OF_PAGE_MAX*0)%256,( 0+NODES_OF_PAGE_MAX*0)/256,	( 1+NODES_OF_PAGE_MAX*0)%256,( 1+NODES_OF_PAGE_MAX*0)/256,	0xF5,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x01,0x02,0x03,0x04	},	// 0 它
	{	( 0+NODES_OF_PAGE_MAX*0)%256,( 0+NODES_OF_PAGE_MAX*0)/256,	( 2+NODES_OF_PAGE_MAX*0)%256,( 2+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 1   
	{	( 1+NODES_OF_PAGE_MAX*0)%256,( 1+NODES_OF_PAGE_MAX*0)/256,	( 3+NODES_OF_PAGE_MAX*0)%256,( 3+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 2   
	{	( 2+NODES_OF_PAGE_MAX*0)%256,( 2+NODES_OF_PAGE_MAX*0)/256,	( 4+NODES_OF_PAGE_MAX*0)%256,( 4+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 3   
	{	( 3+NODES_OF_PAGE_MAX*0)%256,( 3+NODES_OF_PAGE_MAX*0)/256,	( 5+NODES_OF_PAGE_MAX*0)%256,( 5+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 4   
	{	( 4+NODES_OF_PAGE_MAX*0)%256,( 4+NODES_OF_PAGE_MAX*0)/256,	( 6+NODES_OF_PAGE_MAX*0)%256,( 6+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 5   
	{	( 5+NODES_OF_PAGE_MAX*0)%256,( 5+NODES_OF_PAGE_MAX*0)/256,	( 7+NODES_OF_PAGE_MAX*0)%256,( 7+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 6   
	{	( 6+NODES_OF_PAGE_MAX*0)%256,( 6+NODES_OF_PAGE_MAX*0)/256,	( 8+NODES_OF_PAGE_MAX*0)%256,( 8+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 7   
	{	( 7+NODES_OF_PAGE_MAX*0)%256,( 7+NODES_OF_PAGE_MAX*0)/256,	( 9+NODES_OF_PAGE_MAX*0)%256,( 9+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 8   
	{	( 8+NODES_OF_PAGE_MAX*0)%256,( 8+NODES_OF_PAGE_MAX*0)/256,	(10+NODES_OF_PAGE_MAX*0)%256,(10+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 9   
	{	( 9+NODES_OF_PAGE_MAX*0)%256,( 9+NODES_OF_PAGE_MAX*0)/256,	(11+NODES_OF_PAGE_MAX*0)%256,(11+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 10  
	{	(10+NODES_OF_PAGE_MAX*0)%256,(10+NODES_OF_PAGE_MAX*0)/256,	(12+NODES_OF_PAGE_MAX*0)%256,(12+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 11  
	{	(11+NODES_OF_PAGE_MAX*0)%256,(11+NODES_OF_PAGE_MAX*0)/256,	(13+NODES_OF_PAGE_MAX*0)%256,(13+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 12  
	{	(12+NODES_OF_PAGE_MAX*0)%256,(12+NODES_OF_PAGE_MAX*0)/256,	(14+NODES_OF_PAGE_MAX*0)%256,(14+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 13  
	{	(13+NODES_OF_PAGE_MAX*0)%256,(13+NODES_OF_PAGE_MAX*0)/256,	(15+NODES_OF_PAGE_MAX*0)%256,(15+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 14  
	{	(14+NODES_OF_PAGE_MAX*0)%256,(14+NODES_OF_PAGE_MAX*0)/256,	(16+NODES_OF_PAGE_MAX*0)%256,(16+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 15  
	{	(15+NODES_OF_PAGE_MAX*0)%256,(15+NODES_OF_PAGE_MAX*0)/256,	(17+NODES_OF_PAGE_MAX*0)%256,(17+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 16  
	{	(16+NODES_OF_PAGE_MAX*0)%256,(16+NODES_OF_PAGE_MAX*0)/256,	(18+NODES_OF_PAGE_MAX*0)%256,(18+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 17  
	{	(17+NODES_OF_PAGE_MAX*0)%256,(17+NODES_OF_PAGE_MAX*0)/256,	(19+NODES_OF_PAGE_MAX*0)%256,(19+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 18  
	{	(18+NODES_OF_PAGE_MAX*0)%256,(18+NODES_OF_PAGE_MAX*0)/256,	(20+NODES_OF_PAGE_MAX*0)%256,(20+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 19  
	{	(19+NODES_OF_PAGE_MAX*0)%256,(19+NODES_OF_PAGE_MAX*0)/256,	(21+NODES_OF_PAGE_MAX*0)%256,(21+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 20  
	{	(20+NODES_OF_PAGE_MAX*0)%256,(20+NODES_OF_PAGE_MAX*0)/256,	(22+NODES_OF_PAGE_MAX*0)%256,(22+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 21  
	{	(21+NODES_OF_PAGE_MAX*0)%256,(21+NODES_OF_PAGE_MAX*0)/256,	(23+NODES_OF_PAGE_MAX*0)%256,(23+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 22  
	{	(22+NODES_OF_PAGE_MAX*0)%256,(22+NODES_OF_PAGE_MAX*0)/256,	(24+NODES_OF_PAGE_MAX*0)%256,(24+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 23  
	{	(23+NODES_OF_PAGE_MAX*0)%256,(23+NODES_OF_PAGE_MAX*0)/256,	(25+NODES_OF_PAGE_MAX*0)%256,(25+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 24  
	{	(24+NODES_OF_PAGE_MAX*0)%256,(24+NODES_OF_PAGE_MAX*0)/256,	(26+NODES_OF_PAGE_MAX*0)%256,(26+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 25  
	{	(25+NODES_OF_PAGE_MAX*0)%256,(25+NODES_OF_PAGE_MAX*0)/256,	(27+NODES_OF_PAGE_MAX*0)%256,(27+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 26  
	{	(26+NODES_OF_PAGE_MAX*0)%256,(26+NODES_OF_PAGE_MAX*0)/256,	(28+NODES_OF_PAGE_MAX*0)%256,(28+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 27  
	{	(27+NODES_OF_PAGE_MAX*0)%256,(27+NODES_OF_PAGE_MAX*0)/256,	(29+NODES_OF_PAGE_MAX*0)%256,(29+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 28  
	{	(28+NODES_OF_PAGE_MAX*0)%256,(28+NODES_OF_PAGE_MAX*0)/256,	(30+NODES_OF_PAGE_MAX*0)%256,(30+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 29  
	{	(29+NODES_OF_PAGE_MAX*0)%256,(29+NODES_OF_PAGE_MAX*0)/256,	(31+NODES_OF_PAGE_MAX*0)%256,(31+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 30  
	{	(30+NODES_OF_PAGE_MAX*0)%256,(30+NODES_OF_PAGE_MAX*0)/256,	(32+NODES_OF_PAGE_MAX*0)%256,(32+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 31  
	{	(31+NODES_OF_PAGE_MAX*0)%256,(31+NODES_OF_PAGE_MAX*0)/256,	(33+NODES_OF_PAGE_MAX*0)%256,(33+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 32  
	{	(32+NODES_OF_PAGE_MAX*0)%256,(32+NODES_OF_PAGE_MAX*0)/256,	(34+NODES_OF_PAGE_MAX*0)%256,(34+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 33  
	{	(33+NODES_OF_PAGE_MAX*0)%256,(33+NODES_OF_PAGE_MAX*0)/256,	(35+NODES_OF_PAGE_MAX*0)%256,(35+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 34  
	{	(34+NODES_OF_PAGE_MAX*0)%256,(34+NODES_OF_PAGE_MAX*0)/256,	(36+NODES_OF_PAGE_MAX*0)%256,(36+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 35  
	{	(35+NODES_OF_PAGE_MAX*0)%256,(35+NODES_OF_PAGE_MAX*0)/256,	(37+NODES_OF_PAGE_MAX*0)%256,(37+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 36  
	{	(36+NODES_OF_PAGE_MAX*0)%256,(36+NODES_OF_PAGE_MAX*0)/256,	(38+NODES_OF_PAGE_MAX*0)%256,(38+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 37  
	{	(37+NODES_OF_PAGE_MAX*0)%256,(37+NODES_OF_PAGE_MAX*0)/256,	(39+NODES_OF_PAGE_MAX*0)%256,(39+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 38  
	{	(38+NODES_OF_PAGE_MAX*0)%256,(38+NODES_OF_PAGE_MAX*0)/256,	(40+NODES_OF_PAGE_MAX*0)%256,(40+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 39  
	{	(39+NODES_OF_PAGE_MAX*0)%256,(39+NODES_OF_PAGE_MAX*0)/256,	(41+NODES_OF_PAGE_MAX*0)%256,(41+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 40  
	{	(40+NODES_OF_PAGE_MAX*0)%256,(40+NODES_OF_PAGE_MAX*0)/256,	(42+NODES_OF_PAGE_MAX*0)%256,(42+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 41  
	{	(41+NODES_OF_PAGE_MAX*0)%256,(41+NODES_OF_PAGE_MAX*0)/256,	(43+NODES_OF_PAGE_MAX*0)%256,(43+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 42  
	{	(42+NODES_OF_PAGE_MAX*0)%256,(42+NODES_OF_PAGE_MAX*0)/256,	(44+NODES_OF_PAGE_MAX*0)%256,(44+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 43  
	{	(43+NODES_OF_PAGE_MAX*0)%256,(43+NODES_OF_PAGE_MAX*0)/256,	(45+NODES_OF_PAGE_MAX*0)%256,(45+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 44  
	{	(44+NODES_OF_PAGE_MAX*0)%256,(44+NODES_OF_PAGE_MAX*0)/256,	(46+NODES_OF_PAGE_MAX*0)%256,(46+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 45  
	{	(45+NODES_OF_PAGE_MAX*0)%256,(45+NODES_OF_PAGE_MAX*0)/256,	(47+NODES_OF_PAGE_MAX*0)%256,(47+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 46  
	{	(46+NODES_OF_PAGE_MAX*0)%256,(46+NODES_OF_PAGE_MAX*0)/256,	(48+NODES_OF_PAGE_MAX*0)%256,(48+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 47  
	{	(47+NODES_OF_PAGE_MAX*0)%256,(47+NODES_OF_PAGE_MAX*0)/256,	(49+NODES_OF_PAGE_MAX*0)%256,(49+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 48  
	{	(48+NODES_OF_PAGE_MAX*0)%256,(48+NODES_OF_PAGE_MAX*0)/256,	(50+NODES_OF_PAGE_MAX*0)%256,(50+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 49  
	{	(49+NODES_OF_PAGE_MAX*0)%256,(49+NODES_OF_PAGE_MAX*0)/256,	(51+NODES_OF_PAGE_MAX*0)%256,(51+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 50  
	{	(50+NODES_OF_PAGE_MAX*0)%256,(50+NODES_OF_PAGE_MAX*0)/256,	(52+NODES_OF_PAGE_MAX*0)%256,(52+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 51  
	{	(51+NODES_OF_PAGE_MAX*0)%256,(51+NODES_OF_PAGE_MAX*0)/256,	(53+NODES_OF_PAGE_MAX*0)%256,(53+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 52  
	{	(52+NODES_OF_PAGE_MAX*0)%256,(52+NODES_OF_PAGE_MAX*0)/256,	(54+NODES_OF_PAGE_MAX*0)%256,(54+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 53  
	{	(53+NODES_OF_PAGE_MAX*0)%256,(53+NODES_OF_PAGE_MAX*0)/256,	(55+NODES_OF_PAGE_MAX*0)%256,(55+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 54  
	{	(54+NODES_OF_PAGE_MAX*0)%256,(54+NODES_OF_PAGE_MAX*0)/256,	(56+NODES_OF_PAGE_MAX*0)%256,(56+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 55  
	{	(55+NODES_OF_PAGE_MAX*0)%256,(55+NODES_OF_PAGE_MAX*0)/256,	(57+NODES_OF_PAGE_MAX*0)%256,(57+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 56  
	{	(56+NODES_OF_PAGE_MAX*0)%256,(56+NODES_OF_PAGE_MAX*0)/256,	(58+NODES_OF_PAGE_MAX*0)%256,(58+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 57  
	{	(57+NODES_OF_PAGE_MAX*0)%256,(57+NODES_OF_PAGE_MAX*0)/256,	(59+NODES_OF_PAGE_MAX*0)%256,(59+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 58  
	{	(58+NODES_OF_PAGE_MAX*0)%256,(58+NODES_OF_PAGE_MAX*0)/256,	(60+NODES_OF_PAGE_MAX*0)%256,(60+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 59  
	{	(59+NODES_OF_PAGE_MAX*0)%256,(59+NODES_OF_PAGE_MAX*0)/256,	(61+NODES_OF_PAGE_MAX*0)%256,(61+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 60  
	{	(60+NODES_OF_PAGE_MAX*0)%256,(60+NODES_OF_PAGE_MAX*0)/256,	(62+NODES_OF_PAGE_MAX*0)%256,(62+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 61  
	{	(61+NODES_OF_PAGE_MAX*0)%256,(61+NODES_OF_PAGE_MAX*0)/256,	(63+NODES_OF_PAGE_MAX*0)%256,(63+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 62  
	{	(62+NODES_OF_PAGE_MAX*0)%256,(62+NODES_OF_PAGE_MAX*0)/256,	(64+NODES_OF_PAGE_MAX*0)%256,(64+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 63	 
 
	// 第二页
	{	( 0+NODES_OF_PAGE_MAX*1-1)%256,( 0+NODES_OF_PAGE_MAX*1-1)/256,	( 1+NODES_OF_PAGE_MAX*1)%256,( 1+NODES_OF_PAGE_MAX*1)/256,	0xF5,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x01,0x02,0x03,0x04	},	// 0 它
	{	( 0+NODES_OF_PAGE_MAX*1)%256,( 0+NODES_OF_PAGE_MAX*1)/256,	( 2+NODES_OF_PAGE_MAX*1)%256,( 2+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 1   
	{	( 1+NODES_OF_PAGE_MAX*1)%256,( 1+NODES_OF_PAGE_MAX*1)/256,	( 3+NODES_OF_PAGE_MAX*1)%256,( 3+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 2   
	{	( 2+NODES_OF_PAGE_MAX*1)%256,( 2+NODES_OF_PAGE_MAX*1)/256,	( 4+NODES_OF_PAGE_MAX*1)%256,( 4+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 3   
	{	( 3+NODES_OF_PAGE_MAX*1)%256,( 3+NODES_OF_PAGE_MAX*1)/256,	( 5+NODES_OF_PAGE_MAX*1)%256,( 5+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 4   
	{	( 4+NODES_OF_PAGE_MAX*1)%256,( 4+NODES_OF_PAGE_MAX*1)/256,	( 6+NODES_OF_PAGE_MAX*1)%256,( 6+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 5   
	{	( 5+NODES_OF_PAGE_MAX*1)%256,( 5+NODES_OF_PAGE_MAX*1)/256,	( 7+NODES_OF_PAGE_MAX*1)%256,( 7+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 6   
	{	( 6+NODES_OF_PAGE_MAX*1)%256,( 6+NODES_OF_PAGE_MAX*1)/256,	( 8+NODES_OF_PAGE_MAX*1)%256,( 8+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 7   
	{	( 7+NODES_OF_PAGE_MAX*1)%256,( 7+NODES_OF_PAGE_MAX*1)/256,	( 9+NODES_OF_PAGE_MAX*1)%256,( 9+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 8   
	{	( 8+NODES_OF_PAGE_MAX*1)%256,( 8+NODES_OF_PAGE_MAX*1)/256,	(10+NODES_OF_PAGE_MAX*1)%256,(10+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 9   
	{	( 9+NODES_OF_PAGE_MAX*1)%256,( 9+NODES_OF_PAGE_MAX*1)/256,	(11+NODES_OF_PAGE_MAX*1)%256,(11+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 10  
	{	(10+NODES_OF_PAGE_MAX*1)%256,(10+NODES_OF_PAGE_MAX*1)/256,	(12+NODES_OF_PAGE_MAX*1)%256,(12+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 11  
	{	(11+NODES_OF_PAGE_MAX*1)%256,(11+NODES_OF_PAGE_MAX*1)/256,	(13+NODES_OF_PAGE_MAX*1)%256,(13+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 12  
	{	(12+NODES_OF_PAGE_MAX*1)%256,(12+NODES_OF_PAGE_MAX*1)/256,	(14+NODES_OF_PAGE_MAX*1)%256,(14+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 13  
	{	(13+NODES_OF_PAGE_MAX*1)%256,(13+NODES_OF_PAGE_MAX*1)/256,	(15+NODES_OF_PAGE_MAX*1)%256,(15+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 14  
	{	(14+NODES_OF_PAGE_MAX*1)%256,(14+NODES_OF_PAGE_MAX*1)/256,	(16+NODES_OF_PAGE_MAX*1)%256,(16+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 15  
	{	(15+NODES_OF_PAGE_MAX*1)%256,(15+NODES_OF_PAGE_MAX*1)/256,	(17+NODES_OF_PAGE_MAX*1)%256,(17+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 16  
	{	(16+NODES_OF_PAGE_MAX*1)%256,(16+NODES_OF_PAGE_MAX*1)/256,	(18+NODES_OF_PAGE_MAX*1)%256,(18+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 17  
	{	(17+NODES_OF_PAGE_MAX*1)%256,(17+NODES_OF_PAGE_MAX*1)/256,	(19+NODES_OF_PAGE_MAX*1)%256,(19+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 18  
	{	(18+NODES_OF_PAGE_MAX*1)%256,(18+NODES_OF_PAGE_MAX*1)/256,	(20+NODES_OF_PAGE_MAX*1)%256,(20+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 19  
	{	(19+NODES_OF_PAGE_MAX*1)%256,(19+NODES_OF_PAGE_MAX*1)/256,	(21+NODES_OF_PAGE_MAX*1)%256,(21+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 20  
	{	(20+NODES_OF_PAGE_MAX*1)%256,(20+NODES_OF_PAGE_MAX*1)/256,	(22+NODES_OF_PAGE_MAX*1)%256,(22+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 21  
	{	(21+NODES_OF_PAGE_MAX*1)%256,(21+NODES_OF_PAGE_MAX*1)/256,	(23+NODES_OF_PAGE_MAX*1)%256,(23+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 22  
	{	(22+NODES_OF_PAGE_MAX*1)%256,(22+NODES_OF_PAGE_MAX*1)/256,	(24+NODES_OF_PAGE_MAX*1)%256,(24+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 23  
	{	(23+NODES_OF_PAGE_MAX*1)%256,(23+NODES_OF_PAGE_MAX*1)/256,	(25+NODES_OF_PAGE_MAX*1)%256,(25+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 24  
	{	(24+NODES_OF_PAGE_MAX*1)%256,(24+NODES_OF_PAGE_MAX*1)/256,	(26+NODES_OF_PAGE_MAX*1)%256,(26+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 25  
	{	(25+NODES_OF_PAGE_MAX*1)%256,(25+NODES_OF_PAGE_MAX*1)/256,	(27+NODES_OF_PAGE_MAX*1)%256,(27+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 26  
	{	(26+NODES_OF_PAGE_MAX*1)%256,(26+NODES_OF_PAGE_MAX*1)/256,	(28+NODES_OF_PAGE_MAX*1)%256,(28+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 27  
	{	(27+NODES_OF_PAGE_MAX*1)%256,(27+NODES_OF_PAGE_MAX*1)/256,	(29+NODES_OF_PAGE_MAX*1)%256,(29+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 28  
	{	(28+NODES_OF_PAGE_MAX*1)%256,(28+NODES_OF_PAGE_MAX*1)/256,	(30+NODES_OF_PAGE_MAX*1)%256,(30+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 29  
	{	(29+NODES_OF_PAGE_MAX*1)%256,(29+NODES_OF_PAGE_MAX*1)/256,	(31+NODES_OF_PAGE_MAX*1)%256,(31+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 30  
	{	(30+NODES_OF_PAGE_MAX*1)%256,(30+NODES_OF_PAGE_MAX*1)/256,	(32+NODES_OF_PAGE_MAX*1)%256,(32+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 31  
	{	(31+NODES_OF_PAGE_MAX*1)%256,(31+NODES_OF_PAGE_MAX*1)/256,	(33+NODES_OF_PAGE_MAX*1)%256,(33+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 32  
	{	(32+NODES_OF_PAGE_MAX*1)%256,(32+NODES_OF_PAGE_MAX*1)/256,	(34+NODES_OF_PAGE_MAX*1)%256,(34+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 33  
	{	(33+NODES_OF_PAGE_MAX*1)%256,(33+NODES_OF_PAGE_MAX*1)/256,	(35+NODES_OF_PAGE_MAX*1)%256,(35+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 34  
	{	(34+NODES_OF_PAGE_MAX*1)%256,(34+NODES_OF_PAGE_MAX*1)/256,	(36+NODES_OF_PAGE_MAX*1)%256,(36+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 35  
	{	(35+NODES_OF_PAGE_MAX*1)%256,(35+NODES_OF_PAGE_MAX*1)/256,	(37+NODES_OF_PAGE_MAX*1)%256,(37+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 36  
	{	(36+NODES_OF_PAGE_MAX*1)%256,(36+NODES_OF_PAGE_MAX*1)/256,	(38+NODES_OF_PAGE_MAX*1)%256,(38+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 37  
	{	(37+NODES_OF_PAGE_MAX*1)%256,(37+NODES_OF_PAGE_MAX*1)/256,	(39+NODES_OF_PAGE_MAX*1)%256,(39+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 38  
	{	(38+NODES_OF_PAGE_MAX*1)%256,(38+NODES_OF_PAGE_MAX*1)/256,	(40+NODES_OF_PAGE_MAX*1)%256,(40+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 39  
	{	(39+NODES_OF_PAGE_MAX*1)%256,(39+NODES_OF_PAGE_MAX*1)/256,	(41+NODES_OF_PAGE_MAX*1)%256,(41+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 40  
	{	(40+NODES_OF_PAGE_MAX*1)%256,(40+NODES_OF_PAGE_MAX*1)/256,	(42+NODES_OF_PAGE_MAX*1)%256,(42+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 41  
	{	(41+NODES_OF_PAGE_MAX*1)%256,(41+NODES_OF_PAGE_MAX*1)/256,	(43+NODES_OF_PAGE_MAX*1)%256,(43+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 42  
	{	(42+NODES_OF_PAGE_MAX*1)%256,(42+NODES_OF_PAGE_MAX*1)/256,	(44+NODES_OF_PAGE_MAX*1)%256,(44+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 43  
	{	(43+NODES_OF_PAGE_MAX*1)%256,(43+NODES_OF_PAGE_MAX*1)/256,	(45+NODES_OF_PAGE_MAX*1)%256,(45+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 44  
	{	(44+NODES_OF_PAGE_MAX*1)%256,(44+NODES_OF_PAGE_MAX*1)/256,	(46+NODES_OF_PAGE_MAX*1)%256,(46+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 45  
	{	(45+NODES_OF_PAGE_MAX*1)%256,(45+NODES_OF_PAGE_MAX*1)/256,	(47+NODES_OF_PAGE_MAX*1)%256,(47+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 46  
	{	(46+NODES_OF_PAGE_MAX*1)%256,(46+NODES_OF_PAGE_MAX*1)/256,	(48+NODES_OF_PAGE_MAX*1)%256,(48+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 47  
	{	(47+NODES_OF_PAGE_MAX*1)%256,(47+NODES_OF_PAGE_MAX*1)/256,	(49+NODES_OF_PAGE_MAX*1)%256,(49+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 48  
	{	(48+NODES_OF_PAGE_MAX*1)%256,(48+NODES_OF_PAGE_MAX*1)/256,	(50+NODES_OF_PAGE_MAX*1)%256,(50+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 49  
	{	(49+NODES_OF_PAGE_MAX*1)%256,(49+NODES_OF_PAGE_MAX*1)/256,	(51+NODES_OF_PAGE_MAX*1)%256,(51+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 50  
	{	(50+NODES_OF_PAGE_MAX*1)%256,(50+NODES_OF_PAGE_MAX*1)/256,	(52+NODES_OF_PAGE_MAX*1)%256,(52+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 51  
	{	(51+NODES_OF_PAGE_MAX*1)%256,(51+NODES_OF_PAGE_MAX*1)/256,	(53+NODES_OF_PAGE_MAX*1)%256,(53+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 52  
	{	(52+NODES_OF_PAGE_MAX*1)%256,(52+NODES_OF_PAGE_MAX*1)/256,	(54+NODES_OF_PAGE_MAX*1)%256,(54+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 53  
	{	(53+NODES_OF_PAGE_MAX*1)%256,(53+NODES_OF_PAGE_MAX*1)/256,	(55+NODES_OF_PAGE_MAX*1)%256,(55+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 54  
	{	(54+NODES_OF_PAGE_MAX*1)%256,(54+NODES_OF_PAGE_MAX*1)/256,	(56+NODES_OF_PAGE_MAX*1)%256,(56+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 55  
	{	(55+NODES_OF_PAGE_MAX*1)%256,(55+NODES_OF_PAGE_MAX*1)/256,	(57+NODES_OF_PAGE_MAX*1)%256,(57+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 56  
	{	(56+NODES_OF_PAGE_MAX*1)%256,(56+NODES_OF_PAGE_MAX*1)/256,	(58+NODES_OF_PAGE_MAX*1)%256,(58+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 57  
	{	(57+NODES_OF_PAGE_MAX*1)%256,(57+NODES_OF_PAGE_MAX*1)/256,	(59+NODES_OF_PAGE_MAX*1)%256,(59+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 58  
	{	(58+NODES_OF_PAGE_MAX*1)%256,(58+NODES_OF_PAGE_MAX*1)/256,	(60+NODES_OF_PAGE_MAX*1)%256,(60+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 59  
	{	(59+NODES_OF_PAGE_MAX*1)%256,(59+NODES_OF_PAGE_MAX*1)/256,	(61+NODES_OF_PAGE_MAX*1)%256,(61+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 60  
	{	(60+NODES_OF_PAGE_MAX*1)%256,(60+NODES_OF_PAGE_MAX*1)/256,	(62+NODES_OF_PAGE_MAX*1)%256,(62+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 61  
	{	(61+NODES_OF_PAGE_MAX*1)%256,(61+NODES_OF_PAGE_MAX*1)/256,	(63+NODES_OF_PAGE_MAX*1)%256,(63+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 62  
	{	(62+NODES_OF_PAGE_MAX*1)%256,(62+NODES_OF_PAGE_MAX*1)/256,	(64+NODES_OF_PAGE_MAX*1)%256,(64+NODES_OF_PAGE_MAX*1)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 63	 

	// 第三页
	{	( 0+NODES_OF_PAGE_MAX*2-1)%256,( 0+NODES_OF_PAGE_MAX*2-1)/256,	( 1+NODES_OF_PAGE_MAX*2)%256,( 1+NODES_OF_PAGE_MAX*2)/256,	0xF5,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x01,0x02,0x03,0x04	},	// 0 它
	{	( 0+NODES_OF_PAGE_MAX*2)%256,( 0+NODES_OF_PAGE_MAX*2)/256,	( 2+NODES_OF_PAGE_MAX*2)%256,( 2+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 1   
	{	( 1+NODES_OF_PAGE_MAX*2)%256,( 1+NODES_OF_PAGE_MAX*2)/256,	( 3+NODES_OF_PAGE_MAX*2)%256,( 3+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 2   
	{	( 2+NODES_OF_PAGE_MAX*2)%256,( 2+NODES_OF_PAGE_MAX*2)/256,	( 4+NODES_OF_PAGE_MAX*2)%256,( 4+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 3   
	{	( 3+NODES_OF_PAGE_MAX*2)%256,( 3+NODES_OF_PAGE_MAX*2)/256,	( 5+NODES_OF_PAGE_MAX*2)%256,( 5+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 4   
	{	( 4+NODES_OF_PAGE_MAX*2)%256,( 4+NODES_OF_PAGE_MAX*2)/256,	( 6+NODES_OF_PAGE_MAX*2)%256,( 6+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 5   
	{	( 5+NODES_OF_PAGE_MAX*2)%256,( 5+NODES_OF_PAGE_MAX*2)/256,	( 7+NODES_OF_PAGE_MAX*2)%256,( 7+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 6   
	{	( 6+NODES_OF_PAGE_MAX*2)%256,( 6+NODES_OF_PAGE_MAX*2)/256,	( 8+NODES_OF_PAGE_MAX*2)%256,( 8+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 7   
	{	( 7+NODES_OF_PAGE_MAX*2)%256,( 7+NODES_OF_PAGE_MAX*2)/256,	( 9+NODES_OF_PAGE_MAX*2)%256,( 9+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 8   
	{	( 8+NODES_OF_PAGE_MAX*2)%256,( 8+NODES_OF_PAGE_MAX*2)/256,	(10+NODES_OF_PAGE_MAX*2)%256,(10+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 9   
	{	( 9+NODES_OF_PAGE_MAX*2)%256,( 9+NODES_OF_PAGE_MAX*2)/256,	(11+NODES_OF_PAGE_MAX*2)%256,(11+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 10  
	{	(10+NODES_OF_PAGE_MAX*2)%256,(10+NODES_OF_PAGE_MAX*2)/256,	(12+NODES_OF_PAGE_MAX*2)%256,(12+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 11  
	{	(11+NODES_OF_PAGE_MAX*2)%256,(11+NODES_OF_PAGE_MAX*2)/256,	(13+NODES_OF_PAGE_MAX*2)%256,(13+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 12  
	{	(12+NODES_OF_PAGE_MAX*2)%256,(12+NODES_OF_PAGE_MAX*2)/256,	(14+NODES_OF_PAGE_MAX*2)%256,(14+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 13  
	{	(13+NODES_OF_PAGE_MAX*2)%256,(13+NODES_OF_PAGE_MAX*2)/256,	(15+NODES_OF_PAGE_MAX*2)%256,(15+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 14  
	{	(14+NODES_OF_PAGE_MAX*2)%256,(14+NODES_OF_PAGE_MAX*2)/256,	(16+NODES_OF_PAGE_MAX*2)%256,(16+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 15  
	{	(15+NODES_OF_PAGE_MAX*2)%256,(15+NODES_OF_PAGE_MAX*2)/256,	(17+NODES_OF_PAGE_MAX*2)%256,(17+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 16  
	{	(16+NODES_OF_PAGE_MAX*2)%256,(16+NODES_OF_PAGE_MAX*2)/256,	(18+NODES_OF_PAGE_MAX*2)%256,(18+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 17  
	{	(17+NODES_OF_PAGE_MAX*2)%256,(17+NODES_OF_PAGE_MAX*2)/256,	(19+NODES_OF_PAGE_MAX*2)%256,(19+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 18  
	{	(18+NODES_OF_PAGE_MAX*2)%256,(18+NODES_OF_PAGE_MAX*2)/256,	(20+NODES_OF_PAGE_MAX*2)%256,(20+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 19  
	{	(19+NODES_OF_PAGE_MAX*2)%256,(19+NODES_OF_PAGE_MAX*2)/256,	(21+NODES_OF_PAGE_MAX*2)%256,(21+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 20  
	{	(20+NODES_OF_PAGE_MAX*2)%256,(20+NODES_OF_PAGE_MAX*2)/256,	(22+NODES_OF_PAGE_MAX*2)%256,(22+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 21  
	{	(21+NODES_OF_PAGE_MAX*2)%256,(21+NODES_OF_PAGE_MAX*2)/256,	(23+NODES_OF_PAGE_MAX*2)%256,(23+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 22  
	{	(22+NODES_OF_PAGE_MAX*2)%256,(22+NODES_OF_PAGE_MAX*2)/256,	(24+NODES_OF_PAGE_MAX*2)%256,(24+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 23  
	{	(23+NODES_OF_PAGE_MAX*2)%256,(23+NODES_OF_PAGE_MAX*2)/256,	(25+NODES_OF_PAGE_MAX*2)%256,(25+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 24  
	{	(24+NODES_OF_PAGE_MAX*2)%256,(24+NODES_OF_PAGE_MAX*2)/256,	(26+NODES_OF_PAGE_MAX*2)%256,(26+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 25  
	{	(25+NODES_OF_PAGE_MAX*2)%256,(25+NODES_OF_PAGE_MAX*2)/256,	(27+NODES_OF_PAGE_MAX*2)%256,(27+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 26  
	{	(26+NODES_OF_PAGE_MAX*2)%256,(26+NODES_OF_PAGE_MAX*2)/256,	(28+NODES_OF_PAGE_MAX*2)%256,(28+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 27  
	{	(27+NODES_OF_PAGE_MAX*2)%256,(27+NODES_OF_PAGE_MAX*2)/256,	(29+NODES_OF_PAGE_MAX*2)%256,(29+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 28  
	{	(28+NODES_OF_PAGE_MAX*2)%256,(28+NODES_OF_PAGE_MAX*2)/256,	(30+NODES_OF_PAGE_MAX*2)%256,(30+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 29  
	{	(29+NODES_OF_PAGE_MAX*2)%256,(29+NODES_OF_PAGE_MAX*2)/256,	(31+NODES_OF_PAGE_MAX*2)%256,(31+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 30  
	{	(30+NODES_OF_PAGE_MAX*2)%256,(30+NODES_OF_PAGE_MAX*2)/256,	(32+NODES_OF_PAGE_MAX*2)%256,(32+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 31  
	{	(31+NODES_OF_PAGE_MAX*2)%256,(31+NODES_OF_PAGE_MAX*2)/256,	(33+NODES_OF_PAGE_MAX*2)%256,(33+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 32  
	{	(32+NODES_OF_PAGE_MAX*2)%256,(32+NODES_OF_PAGE_MAX*2)/256,	(34+NODES_OF_PAGE_MAX*2)%256,(34+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 33  
	{	(33+NODES_OF_PAGE_MAX*2)%256,(33+NODES_OF_PAGE_MAX*2)/256,	(35+NODES_OF_PAGE_MAX*2)%256,(35+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 34  
	{	(34+NODES_OF_PAGE_MAX*2)%256,(34+NODES_OF_PAGE_MAX*2)/256,	(36+NODES_OF_PAGE_MAX*2)%256,(36+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 35  
	{	(35+NODES_OF_PAGE_MAX*2)%256,(35+NODES_OF_PAGE_MAX*2)/256,	(37+NODES_OF_PAGE_MAX*2)%256,(37+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 36  
	{	(36+NODES_OF_PAGE_MAX*2)%256,(36+NODES_OF_PAGE_MAX*2)/256,	(38+NODES_OF_PAGE_MAX*2)%256,(38+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 37  
	{	(37+NODES_OF_PAGE_MAX*2)%256,(37+NODES_OF_PAGE_MAX*2)/256,	(39+NODES_OF_PAGE_MAX*2)%256,(39+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 38  
	{	(38+NODES_OF_PAGE_MAX*2)%256,(38+NODES_OF_PAGE_MAX*2)/256,	(40+NODES_OF_PAGE_MAX*2)%256,(40+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 39  
	{	(39+NODES_OF_PAGE_MAX*2)%256,(39+NODES_OF_PAGE_MAX*2)/256,	(41+NODES_OF_PAGE_MAX*2)%256,(41+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 40  
	{	(40+NODES_OF_PAGE_MAX*2)%256,(40+NODES_OF_PAGE_MAX*2)/256,	(42+NODES_OF_PAGE_MAX*2)%256,(42+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 41  
	{	(41+NODES_OF_PAGE_MAX*2)%256,(41+NODES_OF_PAGE_MAX*2)/256,	(43+NODES_OF_PAGE_MAX*2)%256,(43+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 42  
	{	(42+NODES_OF_PAGE_MAX*2)%256,(42+NODES_OF_PAGE_MAX*2)/256,	(44+NODES_OF_PAGE_MAX*2)%256,(44+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 43  
	{	(43+NODES_OF_PAGE_MAX*2)%256,(43+NODES_OF_PAGE_MAX*2)/256,	(45+NODES_OF_PAGE_MAX*2)%256,(45+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 44  
	{	(44+NODES_OF_PAGE_MAX*2)%256,(44+NODES_OF_PAGE_MAX*2)/256,	(46+NODES_OF_PAGE_MAX*2)%256,(46+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 45  
	{	(45+NODES_OF_PAGE_MAX*2)%256,(45+NODES_OF_PAGE_MAX*2)/256,	(47+NODES_OF_PAGE_MAX*2)%256,(47+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 46  
	{	(46+NODES_OF_PAGE_MAX*2)%256,(46+NODES_OF_PAGE_MAX*2)/256,	(48+NODES_OF_PAGE_MAX*2)%256,(48+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 47  
	{	(47+NODES_OF_PAGE_MAX*2)%256,(47+NODES_OF_PAGE_MAX*2)/256,	(49+NODES_OF_PAGE_MAX*2)%256,(49+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 48  
	{	(48+NODES_OF_PAGE_MAX*2)%256,(48+NODES_OF_PAGE_MAX*2)/256,	(50+NODES_OF_PAGE_MAX*2)%256,(50+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 49  
	{	(49+NODES_OF_PAGE_MAX*2)%256,(49+NODES_OF_PAGE_MAX*2)/256,	(51+NODES_OF_PAGE_MAX*2)%256,(51+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 50  
	{	(50+NODES_OF_PAGE_MAX*2)%256,(50+NODES_OF_PAGE_MAX*2)/256,	(52+NODES_OF_PAGE_MAX*2)%256,(52+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 51  
	{	(51+NODES_OF_PAGE_MAX*2)%256,(51+NODES_OF_PAGE_MAX*2)/256,	(53+NODES_OF_PAGE_MAX*2)%256,(53+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 52  
	{	(52+NODES_OF_PAGE_MAX*2)%256,(52+NODES_OF_PAGE_MAX*2)/256,	(54+NODES_OF_PAGE_MAX*2)%256,(54+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 53  
	{	(53+NODES_OF_PAGE_MAX*2)%256,(53+NODES_OF_PAGE_MAX*2)/256,	(55+NODES_OF_PAGE_MAX*2)%256,(55+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 54  
	{	(54+NODES_OF_PAGE_MAX*2)%256,(54+NODES_OF_PAGE_MAX*2)/256,	(56+NODES_OF_PAGE_MAX*2)%256,(56+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 55  
	{	(55+NODES_OF_PAGE_MAX*2)%256,(55+NODES_OF_PAGE_MAX*2)/256,	(57+NODES_OF_PAGE_MAX*2)%256,(57+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 56  
	{	(56+NODES_OF_PAGE_MAX*2)%256,(56+NODES_OF_PAGE_MAX*2)/256,	(58+NODES_OF_PAGE_MAX*2)%256,(58+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 57  
	{	(57+NODES_OF_PAGE_MAX*2)%256,(57+NODES_OF_PAGE_MAX*2)/256,	(59+NODES_OF_PAGE_MAX*2)%256,(59+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 58  
	{	(58+NODES_OF_PAGE_MAX*2)%256,(58+NODES_OF_PAGE_MAX*2)/256,	(60+NODES_OF_PAGE_MAX*2)%256,(60+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 59  
	{	(59+NODES_OF_PAGE_MAX*2)%256,(59+NODES_OF_PAGE_MAX*2)/256,	(61+NODES_OF_PAGE_MAX*2)%256,(61+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 60  
	{	(60+NODES_OF_PAGE_MAX*2)%256,(60+NODES_OF_PAGE_MAX*2)/256,	(62+NODES_OF_PAGE_MAX*2)%256,(62+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 61  
	{	(61+NODES_OF_PAGE_MAX*2)%256,(61+NODES_OF_PAGE_MAX*2)/256,	(63+NODES_OF_PAGE_MAX*2)%256,(63+NODES_OF_PAGE_MAX*2)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 62  
	{	(62+NODES_OF_PAGE_MAX*2)%256,(62+NODES_OF_PAGE_MAX*2)/256,	(0+NODES_OF_PAGE_MAX*0)%256, (0+NODES_OF_PAGE_MAX*0)/256,	0xFF,0x00,0x00,0x00,	0x0,0x0,0x0,0x0,	0x00,0x00,0x00,0x00	},	// 63	把链表尾链接到表头
};


unsigned char endian_alian;										// 大小端模式
myBkList_t	mBkListPageBuff[NODES_OF_PAGE_MAX]; 

const myBkList_t mTestNode1 = 
{
	.mNode = {
					.Point = {
									.Previous = 12,
									.Next = 13,
					          },
			 },
};

myBkList_t mTestNode2;


/*************************************************************************************
Function:
Description:
*************************************************************************************/
unsigned char check_endian_alian(void)
{
	unsigned int TestDATA = 0xAABBCCDD;
	unsigned char *p;
	
	p = (unsigned char *)(&TestDATA);
	if( (*p==0xDD)&&(*(p+3)==0xAA) )					// 小端模式
	{
		return(FG_LITTLE_ENDIAN);
	}
	else												// 大端模式
	{
		return(FG_BIG_ENDIAN);
	}

}

/*************************************************************************************
Function:
Description:
	当FLASH擦除后，向FLASH某一地址写入一个字节数。注意：必须是FLASH刚刚擦除才能写入。
	写数据时要按字对齐。
				addr - FLASH绝对地址,要写入的地址
				data - 要写入的数据
*************************************************************************************/
void Bk_Data_Byte(unsigned int addr,unsigned char data)
{
	unsigned int addr_temp = addr;
	unsigned int data_temp;
	
	if(addr%4)														// 先判断地址是否为一个字的首地址
	{
		addr_temp = addr-addr%4;
		data_temp = *((unsigned int *)(addr_temp));
		if( FG_BIG_ENDIAN==endian_alian )							// 大端模式
		{
			data_temp &= ~( (unsigned int)0xff<<((3-addr%4)*8) );
			data_temp |= ( (unsigned int)data<<((3-addr%4)*8) );
		}
		else
		{
			data_temp &= ~( (unsigned int)0xff<<((addr%4)*8) );
			data_temp |= ( (unsigned int)data<<((addr%4)*8) );
		}
	}
	fmc_program(addr_temp,addr_temp+4,&data_temp,1);				// 按字写入
}


/*************************************************************************************
Function:
Description:
	当FLASH擦除后，向FLASH某一地址写入一个字节数。注意：必须是FLASH刚刚擦除才能写入。
	写数据时要按字对齐。
				addr - FLASH绝对地址,要写入的地址
				data - 要写入的数据
*************************************************************************************/
void Bk_Flash_Write(unsigned int addr,unsigned int *buff,unsigned int length)
{
	unsigned int addr_temp = addr;

	addr_temp -= addr%4;
	if(FLASH_PAGE_SIZE<length)	
	{
		length = FLASH_PAGE_SIZE;
	}
	fmc_program(addr_temp,addr_temp+length,buff,length);				// 按字写入
}


/*************************************************************************************
Function:
Description:
	当FLASH擦除后，向FLASH某一地址写入一个字节数。注意：必须是FLASH刚刚擦除才能写入。
	写数据时要按字对齐。
				addr - FLASH绝对地址,要写入的地址
				data - 要写入的数据
*************************************************************************************/
void Bk_Flash_Erase_Page(unsigned int addrPage, unsigned int pagesCnt)
{
	fmc_erase_pages(addrPage, pagesCnt);
}


/*************************************************************************************
Function:
Description:
*************************************************************************************/
void BkData_Init(void)
{
	unsigned char *ptrd = (unsigned char *)ADDR_BK_WRITE_FG;
	//myInt4Bytes_t SlaveId;
	//myInt4Chars_t SlaveName;
	
	endian_alian = check_endian_alian();							// 先判断大小端
	
	if(FG_BK_ZONE_WRITED!=*ptrd)									// 首次上电，数据未备份过
	{
		//fmc_erase_pages((unsigned int)Bk_DataZone,BK_DATA_PAGES);	// 擦除数据区
		//Bk_Data_Byte(ADDR_BK_WRITE_FG,FG_BK_ZONE_WRITED);			// 写入标志位-表示已经记录过
	}
	else
	{
		__nop();
	}	

	
//	//========================================================================
//	// 添加记录
//	SlaveId.Bytes[0] = 0;
//	SlaveId.Bytes[1] = 0;
//	SlaveId.Bytes[2] = 0;
//	SlaveId.Bytes[3] = 8;

//	SlaveName.Chars[0] = '0';
//	SlaveName.Chars[1] = '0';
//	SlaveName.Chars[2] = '0';
//	SlaveName.Chars[3] = '8';
//	
//	BkList_Insert_Record(&SlaveName, &SlaveId);		// 添加一条记录
//	//===========================================================================

//	//========================================================================
//	// 删除记录
//	mTestNode2.mNode.Point.Next = mTestNode1.mNode.Point.Next;
//	mTestNode2.mNode.Point.Previous = mTestNode1.mNode.Point.Previous;
//	
//	
//	SlaveId.Bytes[0] = 0;
//	SlaveId.Bytes[1] = 0;
//	SlaveId.Bytes[2] = 0;
//	SlaveId.Bytes[3] = 5;

//	BkList_Remove_Slave_ID_Record(SlaveId.Integer);				// 删除一条记录
//	//========================================================================

//	//========================================================================
//	// 添加记录
//	SlaveId.Bytes[0] = 0;
//	SlaveId.Bytes[1] = 0;
//	SlaveId.Bytes[2] = 0;
//	SlaveId.Bytes[3] = 9;

//	SlaveName.Chars[0] = '0';
//	SlaveName.Chars[1] = '0';
//	SlaveName.Chars[2] = '0';
//	SlaveName.Chars[3] = '9';
//	
//	BkList_Insert_Record(&SlaveName, &SlaveId);		// 添加一条记录
//	//===========================================================================
//	
//	//========================================================================
//	// 添加记录
//	SlaveId.Bytes[0] = 0;
//	SlaveId.Bytes[1] = 0;
//	SlaveId.Bytes[2] = 0;
//	SlaveId.Bytes[3] = 10;

//	SlaveName.Chars[0] = '0';
//	SlaveName.Chars[1] = '0';
//	SlaveName.Chars[2] = '0';
//	SlaveName.Chars[3] = 'a';
//	
//	BkList_Insert_Record(&SlaveName, &SlaveId);		// 添加一条记录
//	//===========================================================================
}

/*************************************************************************************
Function:
Description:
			向链表中删除某个分机编号的全部数据，即把相同分机号的所有分机ID删除。
			注意：链表头和链表尾是作为链表检索的起始和结束标志，因此不能被覆盖。
				  插入新记录时要区分分机编号，相同分机编号链接到一起。
*************************************************************************************/
unsigned char BkList_Remove_SlaveName(myInt4Chars_t *SlaveNumber)
{
	return 0;
}


/*************************************************************************************
Function:
Description:
			向链表中插入一条记录,即删除一某一个分机号
			注意：链表头和链表尾是作为链表检索的起始和结束标志，因此不能被覆盖。
				  插入新记录时要区分分机编号，相同分机编号链接到一起。
*************************************************************************************/
signed char BkList_Remove_Slave_ID_Record(unsigned int SID)
{
	myBkList_t *mListHead = (myBkList_t*)Bk_DataZone1;
	
	myBkList_t *CurListItem,*addrPreCurItem,*addrNextCurItem;														// 缓存链表当前索引项的数据
	myBkList_t PreCurItem_Temp,CurItem_Temp,NextCurItem_Temp;

	myBkList_t *FirstEmptyItem,*addrPreEmptyItem,*addrNextEmptyItem;	
	myBkList_t PreEmptyItem_Temp,FirstEmptyItem_Temp,NextEmptyItem_Temp;
	
	myBkList_t *mNode;
	
	unsigned char i,j;
	unsigned char ProcessOk = 0;
	unsigned short int Point_Temp;


	//----------------------------- 先查找到要删除的项 --------------------------------------
	CurListItem = mListHead + mListHead->mNode.Point.Next;								// 第一条记录默认为链表头，不保存分机数据，从第二第开始查找
	while( (FG_NODE_VALID==CurListItem->mNode.Data.empty) && (CurListItem->mNode.Point.Next!=0))							// 当前项不为空时
	{
		// 比对ID是否一致？
		if( (CurListItem->mNode.Data.SlaveID.Integer&0xfffffff0)==(SID&0xfffffff0) )	// ID后4位为键值
		{
			ProcessOk = 1;
			break;
		}
		else
		{
			CurListItem = mListHead + CurListItem->mNode.Point.Next;				// 索引下一条记录
		}
	}
	if(0==ProcessOk)	return(-1); 												// 删除失败(链表为空或者未找到相同ID号)
	
	//--------------------------- 找到第一个空项，然后将删除项链接到它前面 --------------------------
	ProcessOk = 0;
	FirstEmptyItem = mListHead + mListHead->mNode.Point.Next;						// 从链表头的下一条开始扫描
	while( (FG_NODE_VALID==FirstEmptyItem->mNode.Data.empty) && (FirstEmptyItem->mNode.Point.Next!=0) ) // 扫描到链表尾时停止
	{
		FirstEmptyItem = mListHead + FirstEmptyItem->mNode.Point.Next;			// 索引下一项
	}	

	//--------------------------- 将要删除项以及它的前项和后项缓存起来 --------------------------
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		CurItem_Temp.mNode2Bytes[j] = CurListItem->mNode2Bytes[j];
	}
	addrPreCurItem = (myBkList_t*)Bk_DataZone1+CurListItem->mNode.Point.Previous;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		PreCurItem_Temp.mNode2Bytes[j] = addrPreCurItem->mNode2Bytes[j];
	}
	addrNextCurItem = (myBkList_t*)Bk_DataZone1+CurListItem->mNode.Point.Next;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		NextCurItem_Temp.mNode2Bytes[j] = addrNextCurItem->mNode2Bytes[j];
	}

	//--------------------------- 将第一个空链表以及它的前项和后项缓存起来 --------------------------
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		FirstEmptyItem_Temp.mNode2Bytes[j] = FirstEmptyItem->mNode2Bytes[j];
	}
	addrPreEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Previous;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		PreEmptyItem_Temp.mNode2Bytes[j] = addrPreEmptyItem->mNode2Bytes[j];
	}
	addrNextEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Next;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		NextEmptyItem_Temp.mNode2Bytes[j] = addrNextEmptyItem->mNode2Bytes[j];
	}

	// 先判断链表当前是否为满(链表为满时要特殊处理)
	if(0==FirstEmptyItem->mNode.Point.Next) 									// 当第一个空项为链表尾时,说明链表当前为满状态(需要特殊处理)
	{
		// 1 - 先将要清空项的前项和后项链接起来,并保存删除项的前项的下链指针(即删除项自身地址)
		PreCurItem_Temp.mNode.Point.Next = CurItem_Temp.mNode.Point.Next;					// 当前项的前项的下链指针指向当项的下一项
		NextCurItem_Temp.mNode.Point.Previous = CurItem_Temp.mNode.Point.Previous;			// 当前项的后项的上链指针指向当项的上一项
		Point_Temp = addrPreCurItem->mNode.Point.Next;									// 保存当前项的地址，用于重新链接时修改空项的前项

		// 2 - 然后把这两项写入FLASH
		if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要修改项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}
		
			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据 - 写入最新数据
			{
				mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
			}
		
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要修改项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}
		
			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}
		
			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 3 - 写入要删除项的下一项
		if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 4 - 重新取空项的前项数据和空项数据，有可能已经被修改
		addrPreEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Previous;	// 重新取空项的前项地址，其值有可以在前一次FLASH写入时被修改
		for(j=0;j<BYTES_OF_NODE;j++)							// 重新缓存空项的前项值，其值有可以在前一次FLASH写入时被修改
		{
			PreEmptyItem_Temp.mNode2Bytes[j] = addrPreEmptyItem->mNode2Bytes[j];
		}

		// 5 - 修改空项的前项数据，修改删除项的数据，修改空项数据
		PreEmptyItem_Temp.mNode.Point.Next = Point_Temp;									// 指向当前删除项
		FirstEmptyItem_Temp.mNode.Point.Previous = Point_Temp;		// 将空链表的上链链指针指向当前要删除的项

		CurItem_Temp.mNode.Data.empty = FG_NODE_INVALID;
		CurItem_Temp.mNode.Point.Previous = FirstEmptyItem->mNode.Point.Previous;			// 当前项的上链指针修改为空项的原上链指针	
		CurItem_Temp.mNode.Point.Next = addrPreEmptyItem->mNode.Point.Next; 				// 当前项的下链指针指向空项
		
		// 5 - 写入空项的前项数据
		if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 6 - 写入删除项的数据
		if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 7 - 写入链表尾数据
		if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		return(0);
	}

	//------------------------------------- 先将数据修改了存于缓存中 -------------------------------------
	PreCurItem_Temp.mNode.Point.Next = CurItem_Temp.mNode.Point.Next;					// 当前项的前项的下链指针指向当项的下一项
	NextCurItem_Temp.mNode.Point.Previous = CurItem_Temp.mNode.Point.Previous;			// 当前项的后项的上链指针指向当项的上一项
	
	//------------------------------------- 执行页擦除和写入动作 -------------------------------------
	// 1 - 写入删除项的前一项
	if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据 - 写入最新数据
		{
			mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
		}

		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}

	// 2 - 写入要删除项的下一项
	if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}
	
	//------------------------------------- 重新缓存空项的前项和后项 -------------------------------------
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		FirstEmptyItem_Temp.mNode2Bytes[j] = FirstEmptyItem->mNode2Bytes[j];
	}
	addrPreEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Previous;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		PreEmptyItem_Temp.mNode2Bytes[j] = addrPreEmptyItem->mNode2Bytes[j];
	}
	addrNextEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Next;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		NextEmptyItem_Temp.mNode2Bytes[j] = addrNextEmptyItem->mNode2Bytes[j];
	}

	Point_Temp = ((unsigned int)CurListItem-(unsigned int)mListHead)/BYTES_OF_NODE; 	// 计算当前项的地址

	PreEmptyItem_Temp.mNode.Point.Next = Point_Temp;									// 将空链表前项的下链指针指向当前要删除的项
	FirstEmptyItem_Temp.mNode.Point.Previous = Point_Temp;				// 将空链表的上链链指针指向当前要删除的项

	CurItem_Temp.mNode.Data.empty = FG_NODE_INVALID;
	CurItem_Temp.mNode.Point.Previous = FirstEmptyItem->mNode.Point.Previous;			// 当前项的上链指针修改为空项的原上链指针
	CurItem_Temp.mNode.Point.Next = addrPreEmptyItem->mNode.Point.Next;					// 当前项的下链指针指向空项
	
	// 3 - 写入要删除项自身
	if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}

	// 4 - 写入第一个空项的前项（删除的地址要插入到空项前面）
	if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}

	// 5 - 写入第一个空项
	if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}
	return(0);
}


/*************************************************************************************
Function:
Description:
			向链表中插入一条记录,即删除一某一个分机号
			注意：链表头和链表尾是作为链表检索的起始和结束标志，因此不能被覆盖。
				  插入新记录时要区分分机编号，相同分机编号链接到一起。
*************************************************************************************/
signed char BkList_Remove_SlaveNum_Record(unsigned int SlaveName)
{
	myBkList_t *mListHead = (myBkList_t*)Bk_DataZone1;
	
	myBkList_t *CurListItem,*addrPreCurItem,*addrNextCurItem;														// 缓存链表当前索引项的数据
	myBkList_t PreCurItem_Temp,CurItem_Temp,NextCurItem_Temp;

	myBkList_t *FirstEmptyItem,*addrPreEmptyItem,*addrNextEmptyItem;	
	myBkList_t PreEmptyItem_Temp,FirstEmptyItem_Temp,NextEmptyItem_Temp;
	
	myBkList_t *mNode;
	
	unsigned char i,j;
	unsigned char ProcessOk = 0;
	unsigned short int Point_Temp;


	//----------------------------- 先查找到要删除的项 --------------------------------------
	CurListItem = mListHead + mListHead->mNode.Point.Next;								// 第一条记录默认为链表头，不保存分机数据，从第二第开始查找
	while( (FG_NODE_VALID==CurListItem->mNode.Data.empty) && (CurListItem->mNode.Point.Next!=0))							// 当前项不为空时
	{
		// 比对ID是否一致？
		if( (CurListItem->mNode.Data.IdName.Integer)==(SlaveName) )					// 分机编号
		{
			ProcessOk = 1;
			break;
		}
		else
		{
			CurListItem = mListHead + CurListItem->mNode.Point.Next;				// 索引下一条记录
		}
	}
	if(0==ProcessOk)	return(-1); 												// 删除失败(链表为空或者未找到相同ID号)
	
	//--------------------------- 找到第一个空项，然后将删除项链接到它前面 --------------------------
	ProcessOk = 0;
	FirstEmptyItem = mListHead + mListHead->mNode.Point.Next;						// 从链表头的下一条开始扫描
	while( (FG_NODE_VALID==FirstEmptyItem->mNode.Data.empty) && (FirstEmptyItem->mNode.Point.Next!=0) ) // 扫描到链表尾时停止
	{
		FirstEmptyItem = mListHead + FirstEmptyItem->mNode.Point.Next;			// 索引下一项
	}	

	//--------------------------- 将要删除项以及它的前项和后项缓存起来 --------------------------
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		CurItem_Temp.mNode2Bytes[j] = CurListItem->mNode2Bytes[j];
	}
	addrPreCurItem = (myBkList_t*)Bk_DataZone1+CurListItem->mNode.Point.Previous;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		PreCurItem_Temp.mNode2Bytes[j] = addrPreCurItem->mNode2Bytes[j];
	}
	addrNextCurItem = (myBkList_t*)Bk_DataZone1+CurListItem->mNode.Point.Next;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		NextCurItem_Temp.mNode2Bytes[j] = addrNextCurItem->mNode2Bytes[j];
	}

	//--------------------------- 将第一个空链表以及它的前项和后项缓存起来 --------------------------
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		FirstEmptyItem_Temp.mNode2Bytes[j] = FirstEmptyItem->mNode2Bytes[j];
	}
	addrPreEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Previous;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		PreEmptyItem_Temp.mNode2Bytes[j] = addrPreEmptyItem->mNode2Bytes[j];
	}
	addrNextEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Next;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		NextEmptyItem_Temp.mNode2Bytes[j] = addrNextEmptyItem->mNode2Bytes[j];
	}

	// 先判断链表当前是否为满(链表为满时要特殊处理)
	if(0==FirstEmptyItem->mNode.Point.Next) 									// 当第一个空项为链表尾时,说明链表当前为满状态(需要特殊处理)
	{
		// 1 - 先将要清空项的前项和后项链接起来,并保存删除项的前项的下链指针(即删除项自身地址)
		PreCurItem_Temp.mNode.Point.Next = CurItem_Temp.mNode.Point.Next;					// 当前项的前项的下链指针指向当项的下一项
		NextCurItem_Temp.mNode.Point.Previous = CurItem_Temp.mNode.Point.Previous;			// 当前项的后项的上链指针指向当项的上一项
		Point_Temp = addrPreCurItem->mNode.Point.Next;									// 保存当前项的地址，用于重新链接时修改空项的前项

		// 2 - 然后把这两项写入FLASH
		if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要修改项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}
		
			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据 - 写入最新数据
			{
				mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
			}
		
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要修改项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}
		
			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}
		
			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 3 - 写入要删除项的下一项
		if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 4 - 重新取空项的前项数据和空项数据，有可能已经被修改
		addrPreEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Previous;	// 重新取空项的前项地址，其值有可以在前一次FLASH写入时被修改
		for(j=0;j<BYTES_OF_NODE;j++)							// 重新缓存空项的前项值，其值有可以在前一次FLASH写入时被修改
		{
			PreEmptyItem_Temp.mNode2Bytes[j] = addrPreEmptyItem->mNode2Bytes[j];
		}

		// 5 - 修改空项的前项数据，修改删除项的数据，修改空项数据
		PreEmptyItem_Temp.mNode.Point.Next = Point_Temp;									// 指向当前删除项
		FirstEmptyItem_Temp.mNode.Point.Previous = Point_Temp;		// 将空链表的上链链指针指向当前要删除的项

		CurItem_Temp.mNode.Data.empty = FG_NODE_INVALID;
		CurItem_Temp.mNode.Point.Previous = FirstEmptyItem->mNode.Point.Previous;			// 当前项的上链指针修改为空项的原上链指针	
		CurItem_Temp.mNode.Point.Next = addrPreEmptyItem->mNode.Point.Next; 				// 当前项的下链指针指向空项
		
		// 5 - 写入空项的前项数据
		if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 6 - 写入删除项的数据
		if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		// 7 - 写入链表尾数据
		if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
			
		}
		else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
		}
		else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		}
		
		return(0);
	}

	//------------------------------------- 先将数据修改了存于缓存中 -------------------------------------
	PreCurItem_Temp.mNode.Point.Next = CurItem_Temp.mNode.Point.Next;					// 当前项的前项的下链指针指向当项的下一项
	NextCurItem_Temp.mNode.Point.Previous = CurItem_Temp.mNode.Point.Previous;			// 当前项的后项的上链指针指向当项的上一项
	
	//------------------------------------- 执行页擦除和写入动作 -------------------------------------
	// 1 - 写入删除项的前一项
	if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据 - 写入最新数据
		{
			mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
		}

		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)addrPreCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}

	// 2 - 写入要删除项的下一项
	if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)addrNextCurItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrNextCurItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrNextCurItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = NextCurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}
	
	//------------------------------------- 重新缓存空项的前项和后项 -------------------------------------
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		FirstEmptyItem_Temp.mNode2Bytes[j] = FirstEmptyItem->mNode2Bytes[j];
	}
	addrPreEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Previous;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		PreEmptyItem_Temp.mNode2Bytes[j] = addrPreEmptyItem->mNode2Bytes[j];
	}
	addrNextEmptyItem = (myBkList_t*)Bk_DataZone1+FirstEmptyItem->mNode.Point.Next;
	for(j=0;j<BYTES_OF_NODE;j++)							// 取一个node数据
	{
		NextEmptyItem_Temp.mNode2Bytes[j] = addrNextEmptyItem->mNode2Bytes[j];
	}

	Point_Temp = ((unsigned int)CurListItem-(unsigned int)mListHead)/BYTES_OF_NODE; 	// 计算当前项的地址

	PreEmptyItem_Temp.mNode.Point.Next = Point_Temp;									// 将空链表前项的下链指针指向当前要删除的项
	FirstEmptyItem_Temp.mNode.Point.Previous = Point_Temp;				// 将空链表的上链链指针指向当前要删除的项

	CurItem_Temp.mNode.Data.empty = FG_NODE_INVALID;
	CurItem_Temp.mNode.Point.Previous = FirstEmptyItem->mNode.Point.Previous;			// 当前项的上链指针修改为空项的原上链指针
	CurItem_Temp.mNode.Point.Next = addrPreEmptyItem->mNode.Point.Next;					// 当前项的下链指针指向空项
	
	// 3 - 写入要删除项自身
	if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)CurListItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)CurListItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)CurListItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = CurItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}

	// 4 - 写入第一个空项的前项（删除的地址要插入到空项前面）
	if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)addrPreEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)addrPreEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)addrPreEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = PreEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}

	// 5 - 写入第一个空项
	if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
	{
		// 要删除项落在第一页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
		
	}
	else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
	{
		// 要删除项落在第二页
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	
	}
	else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
	{
		// 要删除项落在第三页
	
		mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
		for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
		{
			for(j=0;j<sizeof(myBkList_t);j++)
			{
				mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
			}
			mNode++;
		}

		for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
		{
			mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = FirstEmptyItem_Temp.mNode2Bytes[j];
		}
		
		Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
		Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) ); // 写入数据
	}
	return(0);
}


/*************************************************************************************
Function:
Description:
			向链表中插入一条记录，在相应的分机编号下添加一个分机ID
			注意：链表头和链表尾是作为链表检索的起始和结束标志，因此不能被覆盖。
				  插入新记录时要区分分机编号，相同分机编号链接到一起。
			搜索方法:1.先搜索分机号是否有注册过.
					2.分机号未注册过时,将记录插入到最后一个有效记录的后面.
	@SlaveNumber - 分机编号
	@SID		 - 分机ID
*************************************************************************************/
signed char BkList_Insert_Record(myInt4Chars_t *SlaveNumber, myInt4Bytes_t *SID)
{
	myBkList_t *mListHead = (myBkList_t*)Bk_DataZone1;
	myBkList_t *FirstEmptyItem;	
	myBkList_t newItem;
	myBkList_t *mNode;
	
	unsigned char i,j;


	// 先找到可以插入的位置(即第一个空项) 
	FirstEmptyItem = mListHead + mListHead->mNode.Point.Next;						// 从链表头的下一条开始扫描
	while( (FG_NODE_VALID==FirstEmptyItem->mNode.Data.empty) && (FirstEmptyItem->mNode.Point.Next!=0) )	// 扫描到链表尾时停止
	{
		FirstEmptyItem = mListHead + FirstEmptyItem->mNode.Point.Next;			// 索引下一项
	}	

	if(FirstEmptyItem->mNode.Data.empty!=FG_NODE_VALID)								// 找到空项,准备写入数据
	{
		// 先准备好数据
		newItem.mNode.Point.Previous = FirstEmptyItem->mNode.Point.Previous;
		newItem.mNode.Point.Next = FirstEmptyItem->mNode.Point.Next;
		newItem.mNode.Data.empty = FG_NODE_VALID;
		newItem.mNode.Data.IdName.Integer = SlaveNumber->Integer;
		newItem.mNode.Data.SlaveID.Integer = SID->Integer;

		// 先将空项数据读出
		if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1)) )
		{
			// 要删除项落在第一页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据 - 写入最新数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0))/BYTES_OF_NODE].mNode2Bytes[j] = newItem.mNode2Bytes[j];
			}

			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*0), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) );	// 写入数据
			
		}
		else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2)) )
		{
			// 要删除项落在第二页
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1))/BYTES_OF_NODE].mNode2Bytes[j] = newItem.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*1), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) );	// 写入数据
		
		}
		else if( ((unsigned int)FirstEmptyItem>=(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))&&((unsigned int)FirstEmptyItem<(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*3)) )
		{
			// 要删除项落在第三页
		
			mNode = (myBkList_t*)(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2);
			for(i=0;i<NODES_OF_PAGE_MAX;i++)												// 取出整页数据
			{
				for(j=0;j<sizeof(myBkList_t);j++)
				{
					mBkListPageBuff[i].mNode2Bytes[j] = mNode->mNode2Bytes[j];
				}
				mNode++;
			}

			for(j=0;j<sizeof(myBkList_t);j++)												// 修改数据
			{
				mBkListPageBuff[((unsigned int)FirstEmptyItem-(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2))/BYTES_OF_NODE].mNode2Bytes[j] = newItem.mNode2Bytes[j];
			}
			
			Bk_Flash_Erase_Page(BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2,1);
			Bk_Flash_Write( (BK_DATA_START_ADDRESS+FLASH_PAGE_SIZE*2), (unsigned int*)mBkListPageBuff, (BYTES_OF_NODE*NODES_OF_PAGE_MAX) );	// 写入数据
		}
	}
	else
	{
		return(-1);
	}

	return(0);
}


/*************************************************************************************
Function:
Description:
			查询分机ID是否被记录过？同时返回分机编号
			注意：链表头和链表尾是作为链表检索的起始和结束标志，因此不能被覆盖。
				  插入新记录时要区分分机编号，相同分机编号链接到一起。
	@SlaveNumber - 输出分机ID对应的分机编号
	@SID		 - 输入分机ID
*************************************************************************************/
int BkList_Is_SID_Recorded(myInt4Chars_t *SlaveNumber,myInt4Bytes_t *SlaveID)
{
	myBkList_t *node;
	myBkList_t *mListHead = (myBkList_t*)Bk_DataZone1;
	int ret = -1;
	
	node = mListHead + mListHead->mNode.Point.Next;								// 第一条记录默认为链表头，不保存分机数据，从第二条开始查找
	while( (FG_NODE_VALID==node->mNode.Data.empty)&&(node->mNode.Point.Next!=0) )// 当搜索到链表尾时也要结束
	{
		if(node->mNode.Data.SlaveID.Integer==SlaveID->Integer)
		{
			SlaveNumber->Integer = node->mNode.Data.IdName.Integer;
			ret = 0;
			break;
		}
		node = mListHead + node->mNode.Point.Next;
	}

	return(ret);
}


/*************************************************************************************
Function:
Description:
			查询SNUM分机编号是否被记录过？同时返回SID分机ID
			注意：链表头和链表尾是作为链表检索的起始和结束标志，因此不能被覆盖。
				  插入新记录时要区分分机编号，相同分机编号链接到一起。
	@SlaveNumber - 输出分机ID对应的分机编号
	@SID		 - 输入分机ID
*************************************************************************************/
int BkList_Is_SNUM_Recorded(myInt4Chars_t *SlaveNumber,myInt4Bytes_t *SlaveID)
{
	myBkList_t *node;
	myBkList_t *mListHead = (myBkList_t*)Bk_DataZone1;
	int ret = -1;
	
	node = mListHead + mListHead->mNode.Point.Next;								// 第一条记录默认为链表头，不保存分机数据，从第二条开始查找
	while( (FG_NODE_VALID==node->mNode.Data.empty)&&(node->mNode.Point.Next!=0) )// 当搜索到链表尾时也要结束
	{
		if(node->mNode.Data.IdName.Integer==SlaveNumber->Integer)
		{
			SlaveID->Integer = node->mNode.Data.IdName.Integer;
			ret = 0;
			break;
		}
		node = mListHead + node->mNode.Point.Next;
	}

	return(ret);
}


/*************************************************************************************
Function:
Description:
			查找某个分机编号所注册的分机ID个数
			注意：第一条记录默认为链表头，不保存分机数据，从第二第开始查找
*************************************************************************************/
unsigned int BkList_Search_sidCount_sNumber(myInt4Chars_t *SlaveNumber)
{
	myBkList_t *node;
	myBkList_t *mListHead = (myBkList_t*)Bk_DataZone1;
	unsigned int SlaveCount = 0;
	
	node = mListHead + mListHead->mNode.Point.Next;								// 第一条记录默认为链表头，不保存分机数据，从第二条开始查找
	while( (FG_NODE_VALID==node->mNode.Data.empty)&&(node->mNode.Point.Next!=0) )// 当搜索到链表尾时也要结束
	{
		if(node->mNode.Data.IdName.Integer==SlaveNumber->Integer)
		{
			SlaveCount++;
		}
		
		node = mListHead + node->mNode.Point.Next;
	}

	return(SlaveCount);
}



